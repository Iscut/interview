1. HashMap的原理，内部数据结构？
    - 底层使用哈希表（数组 + 链表），当链表过长会将链表转成 红黑树以实现 O(logn) 时间复杂度内查找
1. 讲一下 HashMap 中 put 方法过程？
    1. 对 Key 求 Hash 值，然后再计算 下标。
    1. 如果没有碰撞，直接放入桶中，
    1. 如果碰撞了，以链表的方式链接到后面，
    1. 如果链表长度超过阀值（TREEIFY_THRESHOLD == 8），就把链表转成红黑树。
    1. 如果节点已经存在就替换旧值
    1. 如果桶满了（容量 * 加载因子），就需要 resize。
1. HashMap 中 hash 函数怎么是是实现的？ 还有哪些 hash 的实现方式？
    1. 高 16bit 不变，低 16bit 和高 16bit 做了一个异或
    1. （n - 1） & hash --> 得到下标
    1. 还有哪些 Hash 实现方式：可以参考之前的博客 [Effective Java 学习笔记 -- hashCode()](../reading-notes/Effective-Java.md)
1. HashMap 怎样解决冲突，讲一下扩容过程，假如一个值在原数组中，现在移动了新数组，位置肯定改变了，那是什么定位到在这个值新数组中的位置，
    - 将新节点加到链表后，
    - 容量扩充为原来的两倍，然后对每个节点重新计算哈希值。
